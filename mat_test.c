/*
-----------------------------------------------------------------------------------------------------------------------------------
PHYM004
HW1 - Matrix Calculation
Date: 29/10/20
Author: Joe Salkeld 670008743
-----------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------WELCOME-------------------------------------------------------------

This piece of code is designed to read in a matrix from a text file generated by a separate program with the format:
# ./mat_gen --rows 3 --cols 4 --max 10.0 --min 0.0
# Version = 1.0.2, Revision date = 15-Oct-2019
matrix 3 4
<DATA>
end

where the first two lines describe information about the generated matrix, followed by a definition of the matrix size, then
the data, which is three lines of four tab-separated random values in the interval [0,10] in this example, and finally an end 
statement. Matrices of this format are produced from code written by Dr C.D.H Williams named "mat_gen.c". This text file is 
read in and stored by the program as a 1-D array, and one of six operation can be called by the user to be applied to the 
matrix. These are called as follows: 

-f matrix_1.txt 					Frobenius norm of matrix_1
-t matrix_1.txt 					Transpose of matrix_1
-m matrix_1.txt	matrix_2.txt 		Matrix product matrix_1.matrix_2
-d matrix_1.txt 					Determinant of matrix_1 (square)
-a matrix_1.txt 					Adjoint of matrix_1 (square)
-i matrix_1.txt 					Inverse of matrix_1 (square)

A final command can be used to provide a filename for the output matrix to be written in to, which can then be used as input
for the code again. Calling from the command line is as follows:

-o output.txt						Stores the output matrix in a file output.txt

The operations in this code are called using a getoptlong() function in the main, adapted from Dr C.D.H Williams' matrix 
generating code, before calling the required functions as specified.

For functions which output a single value, such as the Frobenius norm or the determinant, the output will be a 1x1 matrix
with the value beneath. Checks are performed on the request of -d,-a,-i to make sure that the input matrix is square, as 
these functions do not work with non-square matrices.

The code works well for all matrices up to 11x11, after which the run time becomes a significant factor, so it is recommended
to only use these for matrices of 11x11 or smaller. A 12x12 matrix takes up to 6 minutes to run and a 13x13 is estimated to 
be around an hour.

An example of an input and output is shown below for a 5x5 matrix, showing all functions, with the product being the 
multiplication of the matrix with itself.

# ./mat_gen --file matrix5.txt --rows 5 --cols 5 --max 10.0 --min 0.0 
# Version = 1.0.3, Revision date = 16-Oct-2019
matrix 5 5
5.61315096245	8.94021401598	7.47906121308	1.12727936875	6.39872453939	
3.33398715283	4.72390704077	7.72630297939	7.08668538234	9.57682288232	
8.73381454904	9.51536071464	9.54652710797	7.73166229377	2.43364641556	
1.08705154671	3.79661949063	5.65553711059	8.96645677693	4.46737139694	
4.43847737482	9.78610748415	2.28037673621	6.752445361	5.6556464013	
end


# ./mattest -o output.txt -f matrix5.txt 
matrix 1 1
33.384033	
end


# ./mattest -o output.txt -t matrix5.txt 
matrix 5 5
5.613151	3.333987	8.733815	1.087052	4.438477	
8.940214	4.723907	9.515361	3.796619	9.786107	
7.479061	7.726303	9.546527	5.655537	2.280377	
1.127279	7.086685	7.731662	8.966457	6.752445	
6.398725	9.576823	2.433646	4.467371	5.655646	
end


# ./mattest -o output.txt -m matrix5.txt matrix5.txt 
matrix 5 5
156.260761	230.479933	203.421835	180.824388	180.962143	
152.153820	246.265682	197.110568	225.181775	171.198355	
183.332307	267.040605	279.251807	236.847021	218.549120	
97.729405	159.228228	152.352115	182.420590	122.401239	
109.899702	188.591436	181.661464	190.720524	189.822060	
end


# ./mattest -o output.txt -d matrix5.txt 
matrix 1 1
12837.028491	
end


# ./mattest -o output.txt -a matrix5.txt 
matrix 5 5
-3005.657985	3204.613271	2416.858666	-4763.955824	697.169534	
2249.082088	-2700.240876	-1064.614172	2214.796161	736.440896	
1882.933279	-1083.592665	-61.457280	2160.397477	-1975.499909	
-1563.886334	359.774267	521.765882	467.542073	566.320002	
-424.877042	2164.719381	-652.762457	-1522.919749	568.742538	
end


# ./mattest -o output.txt -i matrix5.txt 
matrix 5 5
-0.224206	0.239047	0.180285	-0.355366	0.052005	
0.167770	-0.201424	-0.079415	0.165212	0.054935	
0.140457	-0.080830	-0.004584	0.161154	-0.147362	
-0.116658	0.026837	0.038921	0.034876	0.042244	
-0.031694	0.161477	-0.048693	-0.113602	0.042425	
end

-----------------------------------------------------------------------------------------------------------------------------------
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <getopt.h>

#define MATRIXMAX 150 //defining the maximum size of the matrix, this can store up to a 12x12, after which the code is too slow
#define TEXTMAX 500  //defining a limit for the text file


/*
Two sets of structures defined, one with space for the input file to be stored 
and another with space for the matrix to be stored and analysed.
*/
typedef struct read_in {
 char text[TEXTMAX];
}Read_in;


typedef struct matrix {
 int rows, cols, size, outputrows, outputcols;
 double matrix1[MATRIXMAX], output[MATRIXMAX];
}Matrix;

typedef struct read_in2 {
 char text2[TEXTMAX];
}Read_in2;


typedef struct matrix2 {
 int rows, cols, size;
 double matrix2[MATRIXMAX];
}Matrixx;


void ReadMatrix1(Read_in *mat1mem, Matrix *mat1memory, char *optarg);
void ReadMatrix2(Read_in2 *mat2mem, Matrixx *mat2memory, char *optarg);
double frobenius(Matrix *mat1memory);
void transpose(Matrix *mat1memory);
void product(Matrix *mat1memory, Matrixx *mat2memory);
double det(int rows, int cols, double matrix[rows*rows]);
void adj(Matrix *mat1memory);
void inv(Matrix *mat1memory);



int main(int argc,char ** argv){

    char * output_fname = NULL;
    FILE * output_fd = stdout;
    static int normal_flg;
	double frob = 0;

	
    Read_in *readmem = NULL; 
    readmem = (Read_in *) malloc (100*sizeof(Read_in)); 
	
	if(readmem == NULL){
		printf("Unable to allocate memory properly\n");
	}

	Matrix *matrixmem = NULL; 
    matrixmem = (Matrix *) malloc (sizeof(Matrix));

	if(matrixmem == NULL){
		printf("Unable to allocate memory properly\n");
	}

    Read_in2 *read2mem = NULL; 
    read2mem = (Read_in2 *) malloc (100*sizeof(Read_in2));
	
	if(read2mem == NULL){
		printf("Unable to allocate memory properly\n");
	}

	Matrixx *matrix2mem = NULL; 
    matrix2mem = (Matrixx *) malloc (sizeof(Matrixx)); 
	
	if(matrix2mem == NULL){
		printf("Unable to allocate memory properly\n");
	}

//getoptlong() function and options are adapted from Dr. C.D.H. Williams code "mat_gen.c"

    while (1) {
        static struct option long_options[] = {
            /* These options set flags. */
            {"verbose", no_argument,      &normal_flg, 1},
            {"normal", no_argument,       &normal_flg, 0},
            /* These options donâ€™t set a flag, they are distinguished by their indices. */
            {"frobenius",  	   required_argument,  0, 'f'},
            {"transpose", 	   required_argument,  0, 't'},
            {"matrix product", required_argument,  0, 'm'},
            {"determinant",    required_argument,  0, 'd'},
            {"adjoint",  	   required_argument,  0, 'a'},
            {"inverse",  	   required_argument,  0, 'i'},
			{"output file",    required_argument,  0, 'o'},
            {0, 0, 0, 0}
        };
        
        // getopt_long needs somewhere to store its option index. 
        int option_index = 0;
        
        int c = getopt_long( argc, argv, "f:t:m:d:a:i:o:", long_options, &option_index );
        
        // End of options is signalled with '-1' 
        if (c == -1)
            break;
        
        switch (c) {
            case 0:
                // If this option sets a flag we have nothing to do. 
                if (long_options[option_index].flag != 0) {
                    break;
                }
                printf ("option %s", long_options[option_index].name);
                if (optarg)
                    printf (" with arg %s", optarg);
                printf ("\n");
                break;
				
            case 'o':
                output_fname = optarg;	
				break;
				
            case 'f':
				printf("You have selected the Frobenius norm");
				ReadMatrix1(readmem, matrixmem, optarg);
                frob = frobenius(matrixmem);
				for (int i=0; i <matrixmem->size ; i++){
					matrixmem->output[i] = 0;
				}
				matrixmem->size = 1;
				matrixmem->outputrows = 1;
				matrixmem->outputcols = 1;
				matrixmem->output[0] = frob;
                break;
				
			case 't':
				printf("You have selected the Transpose");
				ReadMatrix1(readmem, matrixmem, optarg);
                transpose(matrixmem);
                break;	
				
			case 'm':
				printf("You have selected the Matrix Product");
				ReadMatrix1(readmem, matrixmem, argv[optind-1]);
				ReadMatrix2(read2mem, matrix2mem, argv[optind]);
				optind++;
                product(matrixmem, matrix2mem);
                break;
				
			case 'd':
				printf("You have selected the Determinant");
				ReadMatrix1(readmem, matrixmem, optarg);
                double determinants = det(matrixmem->rows, matrixmem->cols, matrixmem->matrix1);
				for (int i=0; i <matrixmem->size ; i++){
					matrixmem->output[i] = 0;
				}
				matrixmem->size = 1;
				matrixmem->outputrows = 1;
				matrixmem->outputcols = 1;
				matrixmem->output[0] = determinants;
                break;
				
			case 'a':
				printf("You have selected the Adjoint");
				ReadMatrix1(readmem, matrixmem, optarg);
                adj(matrixmem);
                break;
				
			case 'i':
				printf("You have selected the Inverse");
				ReadMatrix1(readmem, matrixmem, optarg);
                inv(matrixmem);
                break;
				
            case ':':
                // missing option argument 
                fprintf(stderr, "Error: option '-%c' requires an argument\n", optopt);
                break;
            case '?':
            default:
                // invalid option 
                fprintf(stderr, "Warning: option '-%c' is invalid: ignored\n", optopt);
                break;
        }
    }
    
    // Print any remaining command line arguments (not options).
    if (optind < argc) {
        fprintf (stderr, "Error: Unrecognised arguments: ");
        while (optind < argc) {
            fprintf (stderr, "%s ", argv[optind++]);
        }
        fprintf (stderr, "\n");
    }
	
    if (output_fname) {
        output_fd = fopen(output_fname,"w");
        if (!output_fd) {
            fprintf (stderr, "Error: Unable to create file '%s'\n", output_fname);
        }
    }
	
	
	// Printing the output matrix stored in the array, adding a line break at the end of the row
    fprintf( output_fd, "# ");
    for ( int arg_no = 0; arg_no  <argc; arg_no++ ) {
        fprintf(output_fd, "%s ", argv[arg_no]);
    }
    fprintf( output_fd, "\n");
	fprintf( output_fd, "matrix %d %d\n", matrixmem->outputrows, matrixmem->outputcols);
	for (int i = 0; i<(matrixmem->outputrows*matrixmem->outputcols) ; i++){
		if(i>0 && i % matrixmem->outputrows == 0){
			fprintf(output_fd, "\n");
		}
		fprintf( output_fd, "%lf	", matrixmem->output[i]);	
	}	
    fprintf( output_fd, "\n" );
	fprintf( output_fd, "end\n" );
	
	printf("\nOutput file has been created");

	
	
	matrixmem = NULL;
	matrix2mem = NULL;
	readmem = NULL;
	read2mem = NULL;
	free(read2mem);
	free(matrixmem);
	free(matrix2mem);
	free(readmem);
}


/*
---------------------------------------------------------------------------------------------------------------------------------------
Reading in Matrix 1: This function is used to read in a text file and store the matrix inside that file as an array.
In order to do this, the function first counts the number of words in the file, then stores them in an array of strings. It then
searches through this array to find where the information in the header stops and the matrix information begins. It then takes
the first two values after this point and converts them to integers and stores them as the number of rows and columns. It then
loops through the following values and converts them from a string to a double and stores them in a new array, until the loop
reaches the point where the matrix ends. Matrix 1 is then stored in this array for use in the rest of the code.
---------------------------------------------------------------------------------------------------------------------------------------
*/

void ReadMatrix1(Read_in *mat1mem, Matrix *mat1memory, char *optarg){

    FILE *mat1;

	
    if ((mat1 = fopen(optarg, "r")) == NULL){
        printf("Error: %s not Found", optarg);
        exit(1);                //returns an error if the file is not found
    }

	/*
	The number of words in the text file needs to be calculated so each can be stored in an array of strings.
	This is done by reading the file character by character and incrememnting an integer "words" every time a
	space or newline character is read.
	*/
	int words = 0;
	char ch;

    while ((ch = fgetc(mat1)) != EOF){
        // Counting all forms of blank characters.
        if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\0'){
            words++;
		}
    }

    rewind(mat1);
	
	mat1mem = (Read_in *) realloc (mat1mem, words*sizeof(Read_in));

    for (int i=0 ; i <= words ; ++i){
		fscanf(mat1, "%s", mat1mem[i].text);
	}

    fclose(mat1); //closes the file being read

	int matbegin = 0;
	int endfile = 0;
	int matinfo, matinfo2;  //defines integers for the string comparison

	/*
	The loop goes through every string in the array and compares them to the word "matrix" and "end",
	as these define the beginning and end of where the matrix values are stored.
	*/

    for (int i=0 ; i <= words ; ++i){
        matinfo = strcmp("matrix", mat1mem[i].text);
        matinfo2 = strcmp("end", mat1mem[i].text);
        if (matinfo == 0){
            matbegin = i;
        }
        if (matinfo2 == 0){
            endfile = i;
        }
    }

	/*
	Storing the number of rows and colums in a new structure containing the relevant matrix
	information from the file, as well as calculating and storing the number of data points
	in that matrix by multiplying these together.
	*/

    int rowcount = matbegin + 1;
    int colcount = matbegin + 2;

    mat1memory->rows = atoi(mat1mem[rowcount].text);
    mat1memory->cols = atoi(mat1mem[colcount].text);
    mat1memory->size = mat1memory->rows*mat1memory->cols;

	/*
	Looping through and converting all the strings stored to doubles, and then storing them
	in a separate structure which can then be passed to all other functions.
	*/

    int j = matbegin+3;
    int w = 0;
    while (j >= matbegin+3 && j < endfile){
		mat1memory->matrix1[w] = atof(mat1mem[j].text);
        j=j+1;
		w=w+1;
    }
	free(mat1mem);
}


/*
---------------------------------------------------------------------------------------------------------------------------------------
Reading in Matrix 2: This function is used to read in a second file and store the matrix inside that file as an array.
In order to do this, the function first counts the number of words in the file, then stores them in an array of strings. It then
searches through this array to find where the information in the header stops and the matrix information begins. It then takes
the first two values after this point and converts them to integers and stores them as the number of rows and columns. It then
loops through the following values and converts them from a string to a double and stores them in a new array, until the loop
reaches the point where the matrix ends. Matrix 2 is then stored in this array for use in the rest of the code.
---------------------------------------------------------------------------------------------------------------------------------------
*/

void ReadMatrix2(Read_in2 *mat2mem, Matrixx *mat2memory, char *optarg){


    FILE *mat2;

	
    if ((mat2 = fopen(optarg, "r")) == NULL){
        printf("Error: %s not Found", optarg);
        exit(1);                //returns an error if the file is not found
    }

	/*
	The number of words in the text file needs to be calculated so each can be stored in an array of strings.
	This is done by reading the file character by character and incrememnting an integer "words" every time a
	space or newline character is read.
	*/

	int words = 0;
	char ch;

    while ((ch = fgetc(mat2)) != EOF){
        //Counting all forms of blank characters.
        if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\0'){
            words++;
		}
    }

    rewind(mat2);
	
	mat2mem = (Read_in2 *) realloc (mat2mem, words*sizeof(Read_in2));

    for (int i=0 ; i <= words ; ++i){
		fscanf(mat2, "%s", mat2mem[i].text2);
	}

    fclose(mat2); //closes the file being read

	int matbegin = 0;
	int endfile = 0;
	int matinfo, matinfo2;  //defines integers for the string comparison

	/*
	The loop goes through every string in the array and compares them to the word matrix and end,
	as these define the beginning and end of where the matrix values are stored.
	*/

    for (int i=0 ; i <= words ; ++i){
        matinfo = strcmp("matrix", mat2mem[i].text2);
        matinfo2 = strcmp("end", mat2mem[i].text2);
        if (matinfo == 0){
            matbegin = i;
        }
        if (matinfo2 == 0){
            endfile = i;
        }
    }

	/*
	Storing the number of rows and colums in a new structure containing the relevant matrix
	information from the file, as well as calculating and storing the number of data points
	in that matrix by multiplying these together.
	*/

    int rowcount = matbegin + 1;
    int colcount = matbegin + 2;

    mat2memory->rows = atoi(mat2mem[rowcount].text2);
    mat2memory->cols = atoi(mat2mem[colcount].text2);
    mat2memory->size = mat2memory->rows*mat2memory->cols;

	/*
	Looping through and converting all the strings stored to doubles, and then storing them
	in a separate structure which can then be passed to all other functions.
	*/

    int j = matbegin+3;
    int w = 0;
    while (j >= matbegin+3 && j < endfile){
		mat2memory->matrix2[w] = atof(mat2mem[j].text2);
        j=j+1;
		w=w+1;
    }
	free(mat2mem);
}


/*
---------------------------------------------------------------------------------------------------------------------------------------
Frobenius Norm: This function calculates the Frobenius norm, the square root of the sum of the squares of the elements in the
matrix. It is calculated by looping through every element in the matrix and storing its square value, then adding it to a running
sum. The square root is calculated on this sum once the loop ends, and the value of the norm is returned.
---------------------------------------------------------------------------------------------------------------------------------------
*/

double frobenius(Matrix *mat1memory){
	int i = 0;
	double sum = 0, norm;
	double square;
	for (i=0 ; i<mat1memory->size ; i++){
		square = 0;
		square = mat1memory->matrix1[i]*mat1memory->matrix1[i];
		sum = sum + square;
	}

	norm = sqrt(sum);

	return norm;
}


/*
---------------------------------------------------------------------------------------------------------------------------------------
Transpose: This function creates a transpose matrix of the input, one where all the rows and columns are swapped. This is achived 
by looping through the rows of the initial matrix and storing the values in the columns of the output matrix until all the values
are swapped over. 
---------------------------------------------------------------------------------------------------------------------------------------
*/

void transpose(Matrix *mat1memory){
	int i = 0;
	for(i=0 ; i<mat1memory->rows ; i++){
        int j = 0;
		for (j=0 ; j < mat1memory->cols ; j++){
			mat1memory->output[(mat1memory->rows*j) + i] = mat1memory->matrix1[(mat1memory->cols*i) + j];
		}
	}
	mat1memory->outputrows = mat1memory->cols;
	mat1memory->outputcols = mat1memory->rows;
}


/*
---------------------------------------------------------------------------------------------------------------------------------------
Matrix Product: The matrix product creates an output matrix where each element is the result of the sum of the multiplication of all
elements in the row of the first matrix with all the elements in the column of the second matrix. To achieve this two matrices are
read in and stored in separate structures, and then the code loops through the rows of the first and the columns of the second 
multiplying values together and storing their sum in a running total runsum. This is then stored in the output array and the code
loops through all the values needed.  
---------------------------------------------------------------------------------------------------------------------------------------
*/

void product(Matrix *mat1memory, Matrixx *mat2memory){

	// Check to make sure that the matrices can be multiplied
	if (mat1memory->rows != mat2memory->cols){
		printf("\n\nError, the matrices you are trying to multiply are incompatible.");
		exit(1);
	}
	
	mat1memory->outputrows = mat1memory->rows;
	mat1memory->outputcols = mat2memory->cols;

	for( int i = 0; (i < mat1memory->rows); i++){
		for( int j = 0; (j < mat2memory->cols); j++){
			double runsum = 0;
			for( int k = 0; k < mat1memory->cols; k++){
				runsum = runsum + (mat1memory->matrix1[i*mat1memory->cols + k] * mat2memory->matrix2[k * mat2memory->cols +j]);
				mat1memory->output[i * mat2memory->cols +j] = runsum;
			}
		}
	}
}


/*
---------------------------------------------------------------------------------------------------------------------------------------
Determinant: The determinant of a matrix is a value calculated from creating a matrix of cofactors and summing along a row. This is
achieved in this code by creating a recursive function. The code reads in the matrix size, checks that it is square and then creates
a new array which is one row and column smaller. This array is then filled with the values of the matrix that aren't in the row/column
of the value needed, and then that matrix is passed back into the whole function. If the matrix is 2x2, the determinant is calculated 
and returned, and the code will then calculate values again. Once the initial value is made, it is stored in a running total of the
determinant, and then the matrix moves to the next array element, all the way along the first row of elements, at which point the
running sum will be equla to the determinant and that value is returned.  
---------------------------------------------------------------------------------------------------------------------------------------
*/

double det(int rows, int cols, double matrix[rows*rows]){
	
	double determinant;
	
	if (rows != cols){
		printf("\n\nThe matrix is not square");
		exit(1);
	}
	
	else{
		
		if (rows == 1){
			return matrix[0];
		}
		
		if (rows == 2){
			determinant = ((matrix[0]*matrix[3])-(matrix[1] * matrix[2]));
			return determinant;
		}
		
		else{
			double arr[(rows-1)*(rows-1)];
			for(int x = 0; x < rows; x++){
				int i = x / rows; //stores i as the current row number
				int j = x % rows; //stores j as the current column number
				int y = 0;
				for (int z=0 ; z < (rows*rows) ; z++){
					if (z / rows != i && z % rows != j){ //if statement checks the value of z is not in either row i or column j
						arr[y] = matrix[z];
						y++;
					}
				}
				/* Recursive function below keeps a running total of the determinant by multiplying the determinant of the 
				minor matrix by the original value and the power of -1^x */
				determinant = determinant + (matrix[x] * pow(-1, x) *det((rows-1), (rows-1), arr));
			}
		}
		return determinant;
	}
}


/*
---------------------------------------------------------------------------------------------------------------------------------------
Adjoint: The adjoint of matrix is a similar calculation to the determinant, except that instead of summing up the values it along
a row it just stores them and then takes the transpose. To complete this function, the code again is a recursive function, calling
the determinant function again but instead of returning the value it stores it in a separate matrix called cofac[] which is the 
matrix of cofactors. Then the same methodology as in the transpose function is used to create the output adjoint matrix.
N.b. For large matrices, the spacing can cause the matrix to look unaligned, but it is still stored and can be loaded correctly.
---------------------------------------------------------------------------------------------------------------------------------------
*/

void adj(Matrix *mat1memory){

	if (mat1memory->rows != mat1memory->cols){
		printf("\n\nThe matrix is not square");
		exit(1);
	}
	
	//special case for a 1x1 matrix
	if(mat1memory->rows == 1 && mat1memory->cols == 1){
		mat1memory->outputrows = mat1memory->rows;
		mat1memory->outputcols = mat1memory->cols;
		mat1memory->output[0] = 1;
	}
	
	else{
		double cofac[(mat1memory->size)];
		mat1memory->outputrows = mat1memory->rows;
		mat1memory->outputcols = mat1memory->cols;
		double arr[(mat1memory->rows-1)*(mat1memory->rows-1)];
		
		for(int x = 0; x < mat1memory->size; x++){
			int i = x / mat1memory->rows; //stores i as the current row number
			int j = x % mat1memory->rows; //stores j as the current column number
			int y = 0;
			for (int z=0 ; z < (mat1memory->size) ; z++){
				if (z / mat1memory->rows != i && z % mat1memory->rows != j){ //if statement checks the value of z is not in either row i or column j
					arr[y] = mat1memory->matrix1[z];
					y++;
				}
			}
			cofac[x] = (pow(-1, i+j) * det((mat1memory->rows-1), (mat1memory->rows-1), arr)); //storing the cofactor matrix through using the det function
		}
		
		// performing the tranpose operation on the cofac[] matrix
		int p = 0;
        for(p=0 ; p<mat1memory->rows ; p++){
			int q = 0;
			for (q=0 ; q < mat1memory->rows ; q++){
				mat1memory->output[(mat1memory->rows*q) + p] = cofac[(mat1memory->rows*p) + q];
			}
		}
	}
}


/*
---------------------------------------------------------------------------------------------------------------------------------------
Inverse: The inverse is defined as 1/determinant multiplied by the adjoint matrix. In this way its calculation requires the use of 
the same processes defined previously. The code performs the adjoint calculation, before calling the determinant function on the 
original matrix and then taking the inverse, and finally multiplying all the elements of the adjoint matrix by it. 
N.b. For large matrices, the spacing can cause the matrix to look unaligned, but it is still stored and can be loaded correctly.
---------------------------------------------------------------------------------------------------------------------------------------
*/

void inv(Matrix *mat1memory){

	if (mat1memory->rows != mat1memory->cols){
		printf("\n\nThe matrix is not square");
		exit(1);
	}
	
	//special case for a 1x1 matrix
	if(mat1memory->rows == 1 && mat1memory->cols == 1){
		mat1memory->outputrows = mat1memory->rows;
		mat1memory->outputcols = mat1memory->cols;
		double detmat = det(mat1memory->rows, mat1memory->cols, mat1memory->matrix1);
		mat1memory->output[0] = 1/detmat;
	}
	
	else{
		double cofac[(mat1memory->size)];
		double adjoint[(mat1memory->size)];
		mat1memory->outputrows = mat1memory->rows;
		mat1memory->outputcols = mat1memory->cols;
		double arr[(mat1memory->rows-1)*(mat1memory->rows-1)];
		
		for(int x = 0; x < mat1memory->size; x++){
			int i = x / mat1memory->rows; //stores i as the current row number
			int j = x % mat1memory->rows; //stores j as the current column number
			int y = 0;
			for (int z=0 ; z < (mat1memory->size) ; z++){ //if statement checks the value of z is not in either row i or column j
				if (z / mat1memory->rows != i && z % mat1memory->rows != j){
					arr[y] = mat1memory->matrix1[z];
					y++;
				}
			}
			cofac[x] = (pow(-1, i+j) * det((mat1memory->rows-1), (mat1memory->rows-1), arr)); //storing the cofactor matrix through using the det function
		}
		
		// performing the tranpose operation on the cofac[] matrix
		int p = 0;
        for(p=0 ; p<mat1memory->rows ; p++){
			int q = 0;
			for (q=0 ; q < mat1memory->rows ; q++){
				adjoint[(mat1memory->rows*q) + p] = cofac[(mat1memory->rows*p) + q];
			}
		}
		
		// creating the inverse matrix
		double detmat = det(mat1memory->rows, mat1memory->cols, mat1memory->matrix1);
		int a = 0;
		for(a=0 ; a < mat1memory->size ; a++){
			mat1memory->output[a] = (1/detmat)*adjoint[a];
		}
	}
}









